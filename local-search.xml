<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hadoop Learning Note</title>
    <link href="undefined2020/03/11/HadoopLearningNote/"/>
    <url>2020/03/11/HadoopLearningNote/</url>
    
    <content type="html"><![CDATA[<h2 id="1-大数据概述"><a href="#1-大数据概述" class="headerlink" title="1.大数据概述"></a>1.大数据概述</h2><p>大数据是指对海量数据进行分析，从中提取出有价值的信息，从而帮助企业做出判断和决策。<br>处理流程：</p><ol><li>获取数据：数据的采集，收集大量数据从而进行分析。</li><li>处理数据：通过大数据框架/平台对数据进行处理和分析</li><li>展示结果</li></ol><h2 id="2-什么是Hadoop"><a href="#2-什么是Hadoop" class="headerlink" title="2.什么是Hadoop"></a>2.什么是Hadoop</h2><p>Hadoop是一个分布式系统基础框架，使用简单的编程模型跨大型计算机的大型数据集进行分布式处理。主要解决两个问题：</p><ol><li>大数据的存储问题：HDFS，分布式文件系统。</li><li>大数据的计算问题：MapReduce，分布式计算，将一个大的计算任务分成小的任务，通过多个计算机进行并行计算。</li></ol><p><strong>分布式存储示例</strong><br><img src="/img/DistributedFileDemo.png" srcset="/img/loading.gif" alt=""></p><ul><li>为了保存大文件，需要把文件放在多个机器上</li><li>在一个集群内，有一个HDFS Master和多个HDFS Slave来提供访问服务</li></ul><p><strong>分布式计算示例</strong><br><img src="/img/DistributedComputingDemo.png" srcset="/img/loading.gif" alt=""><br><img src="/img/DistributedComputing.png" srcset="/img/loading.gif" alt=""></p><ul><li>将一个大的计算任务拆分成多个小的计算任务，并在多个计算机上进行计算（分布式集群）。</li><li>分布式集群中有一个Yarn Master和多个Yarn Slave来处理计算任务。Master用于接收和分配任务，slave用于运行任务。</li></ul>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Learning Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bayes Algorithm ---ML probalistic</title>
    <link href="undefined2019/11/22/BayesAlgorithm/"/>
    <url>2019/11/22/BayesAlgorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="1-贝叶斯定理"><a href="#1-贝叶斯定理" class="headerlink" title="1.贝叶斯定理"></a>1.贝叶斯定理</h2><p>在引出贝叶斯定理之前，先学习几个定义：</p><ul><li>边缘概率（又称先验概率）：某个事件发生的概率。边缘概率是这样得到的：在联合概率中，把最终结果中那些不需要的事件通过合并成它们的全概率，而消去它们（对离散随机变量用求和得全概率，对连续随机变量用积分得全概率），这称为边缘化（marginalization），比如A的边缘概率表示为P(A)，B的边缘概率表示为P(B)。 </li><li>联合概率表示两个事件共同发生的概率。A与B的联合概率表示为P(A∩B)或者P(A,B)。</li><li>条件概率（又称后验概率）：事件A在另外一个事件B已经发生条件下的发生概率。条件概率表示为P(A|B)，读作“在B条件下A的概率”,。<br>接着，考虑一个问题：P(A|B)是在B发生的情况下A发生的可能性。</li><li>首先，事件B发生之前，我们对事件A的发生有一个基本的概率判断，称为A的先验概率，用P(A)表示；</li><li>其次，事件B发生之后，我们对事件A的发生概率重新评估，称为A的后验概率，用P(A|B)表示；</li><li>类似的，事件A发生之前，我们对事件B的发生有一个基本的概率判断，称为B的先验概率，用P(B)表示；</li><li>同样，事件A发生之后，我们对事件B的发生概率重新评估，称为B的后验概率，用P(B|A)表示。</li></ul><p><strong>贝叶斯定理便是基于下述贝叶斯公式：</strong><br><img src="/img/Bayes.png" srcset="/img/loading.gif" alt=""></p><h2 id="2-贝叶斯定理推导和理解"><a href="#2-贝叶斯定理推导和理解" class="headerlink" title="2.贝叶斯定理推导和理解"></a>2.贝叶斯定理推导和理解</h2><p><strong>1.该公式的推导过程如下：</strong><br>根据条件概率（后验概率），事件B发生的前提下，事件A发生的概率 = 事件A和事件B共同发生的概率（联合概率） / 事件B发生的概率：<br><strong>① P(A|B) = P(A∩B) / P(B)</strong><br>同理，事件A发生的前提下，事件B发生的概率 = 事件A和事件B共同发生的概率（联合概率） / 事件A发生的概率：<br><strong>② P(B|A) = P(A∩B) / P(A)</strong></p><p>由①、②两式子可得：<br><strong>③P(A|B) * P(B) = P(A∩B) = P(B|A) * P(A)</strong></p><p>③两边同时除以<strong>P(B)</strong>:<br><strong>P(A|B) = P(B|A) * P(A) / P(B)</strong><br>③两边同时除以P(A):<br><strong>P(B|A) = P(A|B) * P(B) / P(A)</strong></p><p><strong>2.理解：</strong><br>我们把P(A)称为”先验概率”（Prior probability），即在B事件发生之前，我们对A事件概率的一个判断。P(A|B)称为”后验概率”（Posterior probability），即在B事件发生之后，我们对A事件概率的重新评估。P(B|A)/P(B)称为”可能性函数”（Likelyhood），这是一个调整因子，使得预估概率更接近真实概率。<br>所以，条件概率可以理解成下面的式子：<br><strong>后验概率　＝　先验概率 ｘ 调整因子</strong><br>这就是贝叶斯推断的含义。我们先预估一个”先验概率”，然后加入实验结果，看这个实验到底是增强还是削弱了”先验概率”，由此得到更接近事实的”后验概率”。<br>在这里，如果”可能性函数”P(B|A)/P(B)&gt;1，意味着”先验概率”被增强，事件A的发生的可能性变大；如果”可能性函数”=1，意味着B事件无助于判断事件A的可能性；如果”可能性函数”&lt;1，意味着”先验概率”被削弱，事件A的可能性变小。</p><h2 id="3-贝叶斯应用相关示例"><a href="#3-贝叶斯应用相关示例" class="headerlink" title="3.贝叶斯应用相关示例"></a>3.贝叶斯应用相关示例</h2><p>已知某种疾病的发病率是0.001，即1000人中会有1个人得病。现有一种试剂可以检验患者是否得病，它的准确率是0.99，即在患者确实得病的情况下，它有99%的可能呈现阳性。它的误报率是5%，即在患者没有得病的情况下，它有5%的可能呈现阳性。现有一个病人的检验结果为阳性，请问他确实得病的可能性有多大？</p><p>根据已知信息，我们可以记下：<br>P(A)    = 0.001 <em>患者得病的概率</em></p><p>P(A`)   = 0.999 <em>患者未得病的概率</em></p><p>P(B|A)  = 0.99  <em>患者得病的情况下，检测出为阳性的概率。</em></p><p>P(B|A`) = 0.05  <em>患者未得病的情况下，检测出为阳性的概率。</em></p><p>P(A|B)  = ?     <em>问题为：如果患者被检测为阳性，得病的概率是多少？</em></p><p>根据以上概率，我们可以计算如下几个概率性问题：<br>①患者得病且检测出为阳性的概率（真的有病）   = （患者得病的概率）X（患者得病的情况下，检测出为阳性的概率）<br><code>P(A,B) = P(A) * P(B|A) = 0.001 * 0.99 = 0.00099</code><br>②患者未得病且检测出为阳性的概率（其实没病） = （患者未得病的概率）X（患者未得病的情况下，检测出为阳性的概率）<br><code>P(A`,B) = P(A`)  * P(B|A`) = 0.999 * 0.05 = 0.04995</code><br>从①、②可以知道：<br>如果有100000个人，被诊断出<strong>阳性</strong>且真的<strong>有病</strong>的有99人，被诊断出<strong>阳性</strong>且真的<strong>没病</strong>的有4995。即被诊断出为阳性的人有99+4995 = 5094个人。</p><p>通过归一化因子(normalization)，我们可得出以下概率：</p><p>如果一个人被检测为阳性，真的有病的概率为: P(A|B) = <code>0.00099 / (0.00099 + 0.04995) = 0.019</code>;<br>其实没毛病的概率为: <code>0.04995 / (0.00099 + 0.04995) = 0.98</code></p>]]></content>
    
    
    <categories>
      
      <category>MachineLearning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是EWISE?EWISE论文解读</title>
    <link href="undefined2019/11/22/EWISE/"/>
    <url>2019/11/22/EWISE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-研究问题"><a href="#1-研究问题" class="headerlink" title="1.研究问题"></a>1.研究问题</h2><p>词义消歧（WSD）是自然语言处理（NLP）中一个长期存在但尚未完美解决的问题。其目的是根据文本中的单词，预测出该单词在当前文本中的含义。在字典内，一个单词通常具备多个意思，即一词多义。而WSD的任务就是去分析某个单词在当前文本中所使用的是哪一个含义。<br>WSD语料库通常很小，这是由于昂贵的人工注释成本。 当下supervised的WSD语料库把词义看作是离散的标签，并且对训练过程中未见过的单词应用其使用频率最高的词义（MFS）进行预测。换句话来说，就是在对词义标注这件事情上，传统的WSD是通过一个给定的supervised training set作为训练集，从而对词义进行标注。在测试当中，如果遇到在训练集中没有见过的单词，则假设该单词在当前语境中的词义为该单词使用频率最高的那一个。但是显然这种假设的结果在实际情况中的可靠性是非常差的。</p><h2 id="2-研究目标"><a href="#2-研究目标" class="headerlink" title="2.研究目标"></a>2.研究目标</h2><p>为了解决这一问题，该论文的作者提出了Extended WSD Incorporating Sense Embedding(EWISE),一个监督模型，基于continuous sense embedding space，而不是离散的标签空间。这使得EWISE对不论是在训练集中见过的单词或是没见过的单词，都可以进行词义预测，从而实现zero-shot learning。</p><h2 id="3-研究内容"><a href="#3-研究内容" class="headerlink" title="3.研究内容"></a>3.研究内容</h2><p>EWISE架构是从标注过的词义数据，字典内对单词的定义以及词汇知识库中进行词义嵌入的学习，利用词义的连续空间嵌入向量形式，作为WSD学习的目标。在EWISE中，取得一个单词的词义嵌入向量过程跟WSD任务的训练过程是相互独立的。<br>取得一个单词的词义嵌入向量方式则是通过WordNet语料库，基于字典内对单词的词义的定义从而可以通过查看字典内所定义的词义与WordNet中的不同词义的重叠部分来获取当前的语义。</p><p>词汇知识库(lexical resources)是一个十分重要的资源，它提供了海量的单词以及其所对应的含义。最近的研究成果也显示神经网络可以从字典内抽取出语义信息。因此EWISE作者也是根据单词在字典当中的定义，从而得到其含义。</p><p>在这该项目中，作者使用WordNet关系中的训练信号来学习用于单词定义的编码器。为了获取WordNet中的关系网，作者应用了最近前沿的知识图谱嵌入学习方法，TransE 和 ConvE。<br>ConvE定义了一个评分系统，其对知识图谱中实体的三要素(h,l,t)进行相异性打分。<br>ConvE定义了一个评分系统，其对知识图谱中实体的三要素(h,l,t)进行相异性打分。</p><p>为了得到当前单词的在文中的词义嵌入(sense embedding)形式，EWISE对该单词的定义进行了革新。WISE利用WordNet和ConvE去学习一种新的用于单词定义的句子编码器。</p><h2 id="4-解决思路"><a href="#4-解决思路" class="headerlink" title="4.解决思路"></a>4.解决思路</h2><p>EWISE主要由两部分组成：<br><strong>1.Attentive Context Encoder：</strong><br>该部分的主要目的是将sequence of tokens 转化为context-aware embeddings。context-aware embeddings 可以理解将一个句子转 化为将上下文语义考虑在内的vector。这里不难想到将会运用Bi-directional LSTM模型 + attention 去将句子进行向量化。之后EWISE选择接上一个投影层，从而输出每个输入的token所对应的embedding，即向量。<br><strong>2.Definition Encoder：</strong><br>在EWISE中，一个单词的定义embedding的学习过程是跟WSD任务相互独立的，这在前文也提到过。</p><p><strong>WSD的处理：</strong><br>WSD处理的问题是将句子中的单词进行正确的词义标注，例如将句子中bank的词语标注为financial institution。<br>每个单词所对应语义的可能选项可以从语料库中获取，例如WordNet。在EWSIE中，作者选择基于WordNet的词义候选框架，由Raganato提出。<br>更具体的，根据给定任意长度的连续单词串x = &lt;x<sup>1</sup>,x<sup>2</sup>,x<sup>3</sup>…..,x<sup>T</sup> &gt;预测其对应的词义y = &lt;y<sup>1</sup>,y<sup>2</sup>,y<sup>y</sup>…..,y<sup>T</sup> &gt; 注意,y<sup>i</sup>是从预先定义好的语义库<em>S</em>中获得的。在实验过程中，单词<em>w</em>的候选词义<em>S<sub>w</sub></em>认为是已知的。<br><strong>Attentive Context Encoder：</strong><br>BiLSTM已经被证实其有能力根据单词所在的上下文，为单词标注出正确的词义。在EWISE中，作者结合了BiLSTM和self-attention层去获取单词的词义嵌入向量。然后根据<br>trained sense embeddings的输出结果去对Attentive Context Encoder进行训练。</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes--Medium</title>
    <link href="undefined2019/11/06/LeetCode_mid/"/>
    <url>2019/11/06/LeetCode_mid/</url>
    
    <content type="html"><![CDATA[<h2 id="1-最长回文子串"><a href="#1-最长回文子串" class="headerlink" title="1.最长回文子串"></a>1.最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p><strong>示例1:</strong><br><code>输入：&quot;babad&quot;</code><br><code>输出：&quot;bab&quot; (注意: &quot;aba&quot; 也是一个有效答案。)</code><br><strong>示例2:</strong><br><code>输入：&quot;cbbd&quot;</code><br><code>输出：&quot;bb&quot;</code></p><pre><code class="python">class Solution(object):    def longestPalindrome(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: str        &quot;&quot;&quot;        size = len(s)        if size &lt;2:                #如果字符串长度小于2，则该字符串一定为回文字符串            return s        res = s[0]                        dp = [[False for _ in range(size)] for _ in range(size)]   #初始化一个二维数组，如果字符串长度为3，dp = [[False,False,False],[False,False,False],[False,False,False],[False,False,False]]        curr_max = 1        for r in range(1,size):               #定义右边界r，从1 -- 字符串末尾            for l in range(r):                #定义左边界，从 0 -- 右边界                if s[l] == s[r] and ( r - l &lt;=2 or dp[l + 1][r - 1]):  #如果左边界等于右边界，并且(1.数组长度小于等于三，证明首尾元素相同，必为一个回文子串 或者 2.去除左右边界后，其子串为回文字串，即dp[l + 1][r - 1] = True，若子串不为回文字串，则s[l,r]必不为回文字串 )                    dp[l][r] = True           #s[l,r]为回文字串                    if r-l+1 &gt; curr_max:      #记录该回文字串长度，并与现有最大值对比，如果比现有值大，则将此长度记录为现有最长回文字串，并将该字串记录到res内。                        curr_max = r - l + 1                        res = s[l:r+1]        return res</code></pre><p><strong>知识要点：</strong></p><ul><li>采用动态规划处理此类问题：</li></ul><ol><li>定义 “状态”，这里 “状态”数组是二维数组。<br><code>dp[l][r]</code> 表示子串 <code>s[l, r]</code>（包括区间左右端点）是否构成回文串，是一个二维布尔型数组。即如果子串 <code>s[l,r]</code>是回文串，那么 <code>dp[l][r] = true</code>。</li><li>找到 “状态转移方程”:</li></ol><ul><li>当子串只包含1个字符，它一定是回文子串；</li><li>当子串包含2个以上字符的时候：如果<code>s[l, r]</code>是一个回文串，例如 “abccba”，那么这个回文串两边各往里面收缩一个字符（如果可以的话）的子串<code>s[l + 1, r - 1]</code>也一定是回文串，<strong>即：如果<code>dp[l][r] == true</code>成立，一定有<code>dp[l + 1][r - 1] = true</code>成立。</strong></li><li>根据这一点，我们可以知道，给出一个子串<code>s[l, r]</code>，如果<code>s[l] != s[r]</code>，那么这个子串就一定不是回文串。如果<code>s[l] == s[r]</code>成立，就接着判断<code>s[l + 1]</code>与<code>s[r - 1]</code>，这很像中心扩散法的逆方法。</li><li>事实上，<code>当s[l] == s[r]</code>成立的时候，<code>dp[l][r]</code>的值由<code>dp[l + 1][r - l]</code>决定，这一点也不难思考：当左右边界字符串相等的时候，整个字符串是否是回文就完全由“原字符串去掉左右边界”的子串是否回文决定。但是这里还需要再多考虑一点点：“原字符串去掉左右边界”的子串的边界情况:</li></ul><ol><li>当原字符串的元素个数为3个的时候，<strong>如果左右边界相等</strong>，那么去掉它们以后，只剩下1个字符，它一定是回文串，故原字符串也一定是回文串；</li><li>当原字符串的元素个数为2个的时候，<strong>如果左右边界相等</strong>，那么去掉它们以后，只剩下0个字符，显然原字符串也一定是回文串。</li></ol><ul><li>综上，如果一个字符串的左右边界相等，以下二者之一成立即可：</li></ul><ol><li>去掉左右边界以后的字符串不构成区间，即<code>s[l + 1, r - 1]</code>至少包含两个元素的反面，即<code>l - r &gt;= -2</code>，或者 <code>r - l &lt;= 2</code>；</li><li>去掉左右边界以后的字符串是回文串，具体说，它的回文性决定了原字符串的回文性。<br>于是整理成“状态转移方程”：<br><code>dp[l, r] = (s[l] == s[r] and (l - r &gt;= -2 or dp[l + 1, r - 1]))</code><br>或者<br><code>dp[l, r] = (s[l] == s[r] and (r - l &lt;= 2 or dp[l + 1, r - 1]))</code><br>因为要构成子串<code>l</code>一定小于等于<code>r</code>，我们只关心 “状态数组上三角”的那部分取值。理解上面的“状态转移方程”中的 <code>(r - l &lt;= 2 or dp[l + 1, r - 1])</code>这部分是关键，因为<code>or</code>是短路运算，因此，如果收缩以后不构成区间，那么就没有必要看继续<code>dp[l + 1, r - 1]</code>的取值。</li></ol><ul><li>时间复杂度 <em>O(n^2)</em></li><li>空间复杂度 <em>O(n^2)</em>，二维 dp 问题，一个状态得用二维有序数对表示，因此空间复杂度是<em>O(n^2)</em>。</li></ul><h2 id="2-无重复字符的最长子串"><a href="#2-无重复字符的最长子串" class="headerlink" title="2.无重复字符的最长子串"></a>2.无重复字符的最长子串</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p><strong>示例1:</strong><br><code>输入：&quot;abcabcbb&quot;</code><br><code>输出：&quot;3&quot; (因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。)</code><br><strong>示例2:</strong><br><code>输入：&quot;bbbbb&quot;</code><br><code>输出：&quot;1&quot; (因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。)</code></p><pre><code class="python">class Solution(object):    def lengthOfLongestSubstring(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: int        &quot;&quot;&quot;        max_len = 0        curr_len = 0        str_set = []        for i in s:                             #从左到右依次遍历字符串中的字符            if i not in str_set:                #如果该字符未曾出现在以后的队列内，证明为新字符                str_set.append(i)               #将其加入队列                curr_len += 1                   #更新队列长度            else:                               #如果发现队列内已有该元素                index = str_set.index(i)        #记录队列内该重复元素的index                str_set.append(i)               #将新元素加入至队列末尾                str_set = str_set[index+1:]     #移除原先队列内该重复元素左侧的所有元素，包括该重复元素，更新新队列。                # print(str_set)                curr_len = len(str_set)         #更新队列长度            if curr_len &gt; max_len:              #如果现有队列的长度大于现有最大长度，则将其保存                max_len = curr_len        return max_len</code></pre><p><strong>知识要点：</strong></p><ul><li><strong>滑动窗口</strong><br>如字符串为：<code>abcabcbb</code>，进入这个队列（窗口）为<code>abc</code>满足题目要求，当再进入<code>a</code>，队列变成了<code>abca</code>，这时候不满足要求。所以，把队列的左边的元素移出队列即可。</li></ul><p>一直维持这样的队列，找出队列出现最长的长度时候，返回该长度。</p><h2 id="3-两数相加"><a href="#3-两数相加" class="headerlink" title="3.两数相加"></a>3.两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例:</strong><br><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</code><br><code>输出：7 -&gt; 0 -&gt; 8</code><br><code>原因：342 + 465 = 807</code></p><pre><code class="python">class Solution(object):    def addTwoNumbers(self, l1, l2):        &quot;&quot;&quot;        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        &quot;&quot;&quot;        res = ListNode(0)        r = res        carry = 0        while(l1 or l2):            a = l1.val if l1 else 0            b = l2.val if l2 else 0            temp = a + b + carry            carry = temp // 10            r.next = ListNode(temp % 10)            r= r.next            if l1: l1 = l1.next            if l2: l2 = l2.next        if carry &gt; 0:                             #如最后一组数字相加扔需进位，则在链表末尾附上1            r.next = ListNode(1)        return res.next</code></pre><p><strong>知识要点：</strong></p><ul><li>同时遍历两个链表，如果一长一短，则短的剩余部分按0处理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Top100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes--Easy</title>
    <link href="undefined2019/11/06/LeetCode_easy/"/>
    <url>2019/11/06/LeetCode_easy/</url>
    
    <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong><br><code>给定 nums = [2, 7, 11, 15], target = 9.</code><br><code>因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]</code></p><pre><code class="python">class Solution(object):    def twoSum(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: List[int]        &quot;&quot;&quot;        hashmap = {}        for i,num in enumerate(nums):            diff = target - num            if diff in hashmap:                return [i, hashmap[diff]]            else:                hashmap[num] = i</code></pre><p><strong>知识要点：</strong></p><ul><li>用字典储存数据，加快算法速度。 因题目要求返回满足要求的数字的index，所以通过<code>hasmap[num] = i</code>的形式储存数据，其中key = 数字，value = 该数字在数组内所对应的index。</li><li>通过<code>enumerate</code>方法获取数字的index和数值。</li><li>判断 <code>diff = target - num</code> 是否在字典内，如果在则返回当前num的index以及符合要求的已存数字(diff)的index，通过<code>hashmap[diff]</code>获取。</li><li>注意if–else中的判断顺序不能颠倒，否则会返回重复元素</li></ul><h2 id="2-有效的括号"><a href="#2-有效的括号" class="headerlink" title="2.有效的括号"></a>2.有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘， ‘]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：<br>1.左括号必须用相同类型的右括号闭合。<br>2.左括号必须以正确的顺序闭合。</p><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例:</strong><br><code>输入: &quot;()&quot;</code><br><code>输出: true</code></p><p><code>输入: &quot;()[]{}&quot;</code><br><code>输出：ture</code></p><p><code>输入: &quot;(]&quot;</code><br><code>输出：false</code></p><pre><code class="python">class Solution(object):    def isValid(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: bool        &quot;&quot;&quot;        stack = []        brackets = {&#39;)&#39; : &#39;(&#39;, &#39;}&#39;:&#39;{&#39;,&#39;]&#39;:&#39;[&#39;}   #{key=右括号：value=左括号}        topItem = &#39;&#39;        for i in s:            if i in brackets:       #遇到右括号                topItem = stack.pop() if stack else &#39;#&#39;   #pop出栈顶端左括号                if topItem != brackets[i]:                    return False            else:                stack.append(i)     #如没遇到右括号，将左括号入栈        return not stack</code></pre><p><strong>知识要点：</strong></p><ul><li>注意到如果一个字符串合法，如括号的左半部分在其中出现，其对应的右半部分必将随后出现这一规律。（也可理解为如果括号的右半部分率先出现，即右括号的index&lt;其对应左括号的index，则该字符串不合法。）</li><li>可以用栈的数据结构来处理此类问题，即从左到右遍历字符串，遇到左括号则将其进栈，遇到与之对应的右括号（通过字典来完成对应关系）则将其出栈。</li><li>因栈类数据结构有着FIFO的特点，因此可以保证括号配对的正确性。如给定字符串<code>{[[]{}]}</code>,通过栈可实现从内部括号到外部括号的层层判断。</li></ul><h2 id="3-合并链表"><a href="#3-合并链表" class="headerlink" title="3.合并链表"></a>3.合并链表</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例:</strong><br><code>输入: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</code><br><code>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></p><pre><code class="python">class Solution(object):    def mergeTwoLists(self, l1, l2):        &quot;&quot;&quot;        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not l1:            return l2        if not l2:            return l1        if l1.val &gt; l2.val:            l2.next = self.mergeTwoLists(l1,l2.next)            return l2        else:            l1.next = self.mergeTwoLists(l1.next,l2)            return l1</code></pre><p><strong>知识要点：</strong></p><ul><li>运用递归思想，终止条件为两条链表<code>l1</code>遍历完之后返回<code>l2</code>,<code>l2</code>遍历完之后返回<code>l1</code>，当两者都为空时结束。</li><li>返回值：每一层调用都返回排序好的链表头。</li><li>本级递归内容：如果<code>l1</code>的<code>val</code>值更小，则将<code>l1.next</code>与排序好的链表头相接,<code>l2</code>同理。</li><li>可想象在最后一步时应做的步骤，无非为以下几种种情况：</li></ul><ol><li>如<code>l1</code>末位 &gt; <code>l2</code>当前元素，则将<code>l1</code>末位元素追加到<code>l2</code>当前元素后，返回<code>l2</code>。</li><li>如<code>l1</code>末位 &lt; <code>l2</code>当前元素，则将<code>l2</code>剩下的元素追加到<code>l1</code>后，返回<code>l1</code>。</li><li>如<code>l1,l2</code>都为空，则证明排序完毕。</li></ol><h2 id="4-爬楼梯"><a href="#4-爬楼梯" class="headerlink" title="4.爬楼梯"></a>4.爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例:</strong><br><code>输入: 2</code><br><code>输出: 2</code><br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol><pre><code class="python">class Solution(object):    def climbStairs(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: int        &quot;&quot;&quot;        if n &lt;= 2:            return n        return climbStairs(n-1) + climbStairs(n-2)</code></pre><p><strong>知识要点：</strong></p><ul><li>采用递归思想：(自顶而下)</li></ul><ol><li>第一步，我们有两个选择。选择爬一个台阶时，会造就 <em>f(n-1)</em> 种可能性路线；选择爬两个台阶的时，会造就 f(n-2) 种可能性路线；</li><li>因为我们有两个选择，两种可能性，所以总的可能性是 <em>f(n) = f(n-1) + f(n-2)</em>；</li><li>以此类推，如果我们有三个选择，一步一个台阶或两个台阶或三个台阶，那么，总的可能性就为 <em>f(n) = f(n-1) + f(n-2) + f(n-3)</em></li></ol><ul><li><p>时间复杂度<em>O(n^2)</em></p></li><li><p>采用动态规划：(自下而上)<br>…</p></li></ul><h2 id="4-二叉树的最近公共祖先"><a href="#4-二叉树的最近公共祖先" class="headerlink" title="4.二叉树的最近公共祖先"></a>4.二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p><p><strong>示例:</strong><br><code>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</code><br><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</code><br><code>输出: 3</code></p><p>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br><img src="/img/binarytree.png" srcset="/img/loading.gif" alt=""></p><pre><code class="python">class Solution(object):    def lowestCommonAncestor(self, root, p, q):        &quot;&quot;&quot;        :type root: TreeNode        :type p: TreeNode        :type q: TreeNode        :rtype: TreeNode        &quot;&quot;&quot;        if root in (None,p,q):    # 如果该节点的左子树和右子树包含p或者q，那么此时的根节点就是最近公共祖先；亦或是该节点为p或q中的一个            return root        left = lowestCommonAncestor(root.left,p,q)        right = lowestCommonAncestor(root.right,p,q)        return right if left is None else left if right is None else root</code></pre><p><strong>知识要点：</strong></p><ul><li>采用递归思想：先采用深度遍历（DFS）遍历二叉树</li></ul><ol><li>如果左子树和右子树包含<code>p</code>或者<code>q</code>，那么此时的根节点就是最近公共祖先（LCA）。</li><li>如果左子树包含p和q, 那么到root-&gt;left中继续查找，最近公共祖先在左子树里面</li><li>如果右子树包含p和q，那么到root-&gt;right中继续查找，最近公共祖先在右子树里面</li></ol><h2 id="5-杀死进程"><a href="#5-杀死进程" class="headerlink" title="5.杀死进程"></a>5.杀死进程</h2><p>给 n 个进程，每个进程都有一个独一无二的 PID （进程编号）和它的 PPID （父进程编号）。</p><p>每一个进程只有一个父进程，但是每个进程可能会有一个或者多个孩子进程。它们形成的关系就像一个树状结构。只有一个进程的 PPID 是 0 ，意味着这个进程没有父进程。所有的 PID 都会是唯一的正整数。</p><p>我们用两个序列来表示这些进程，第一个序列包含所有进程的 PID ，第二个序列包含所有进程对应的 PPID。</p><p>现在给定这两个序列和一个 PID 表示你要杀死的进程，函数返回一个 PID 序列，表示因为杀这个进程而导致的所有被杀掉的进程的编号。</p><p>当一个进程被杀掉的时候，它所有的孩子进程和后代进程都要被杀掉。</p><p>你可以以任意顺序排列返回的 PID 序列。</p><p><strong>示例:</strong><br><code>输入：</code><br><code>pid =  [1, 3, 10, 5]</code><br><code>ppid = [3, 0, 5, 3]</code><br><code>kill = 5</code><br><code>输出: [5,10]</code></p><p>解释:</p><pre><code>           3         /   \        1     5             /            10</code></pre><pre><code class="python">class TreeNode:    def __init__(self,x):        self.val = x        self.child = []class Solution:    def killProcess(self, pid: List[int], ppid: List[int], kill: int) -&gt; List[int]:        dic = {}        for _ in pid:                                  #建立dic[进程名] = Node(进程名) 类型字典            dic[_] = TreeNode(_)        for i in range(len(ppid)):                     #遍历ppid            if ppid[i] &gt; 0:                            #如果该ppid的值等于零，证明其index对应的pid为根节点，此实例中为3                node = dic.get(ppid[i])                #获取该ppid(进程名)所对应的Node(进程名)                node.child.append(dic.get(pid[i]))     #将Node.child信息储存起来，注意`dic.get(pid[i])`获取的是该ppid所对应的子进程        kills = []        kills.append(kill)        kills = self.kill_res(dic[kill], kills)        return kills    def kill_res(self, node,kills):        if len(node.child) == 0:                       #表明该进程已无子进程            return kills        for i in node.child:                           #遍历子当前进程中的每一个进程            kills.append(i.val)                        #储存每个子进程的名字            kills = self.kill_res(i,kills)             #递归查找当前子进程的子进程        return kills  </code></pre><p><strong>知识要点：</strong></p><ul><li>新建TreeNode类并赋予child属性，通过建立字典以存储进程之间的父子关系。<code>dic[进程名] = Node(进程名).child ---&gt; 指向另一进程名</code>。</li></ul><ol><li>pid中的各个元素为ppid中对应元素的子系元素，即ppid[0]的子进程为pid[0],ppid[1]的子进程为pid[1]，以此类推。如果ppid中的某一项值为0，则证明该位置（index）所对应的pid为根节点。</li><li>进程关系储存完毕后，通过调用<code>kill_res</code>方法，递归找出所有被杀死的进程。</li></ol><h2 id="6-对称二叉树"><a href="#6-对称二叉树" class="headerlink" title="6.对称二叉树"></a>6.对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>返回：true</p><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><pre><code>    1   / \  2   2   \   \   3    3</code></pre><p>返回：false</p><pre><code class="python">class Solution(object):    def isSymmetric(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: bool        &quot;&quot;&quot;        if not root:            return True        return self.isMirror(root.left,root.right)    def isMirror(self,l,r):        if l== None and r == None:            return True        if l == None or r == None:            return False        return l.val == r.val and self.isMirror(l.left,r.right) and self.isMirror(l.right,r.left)</code></pre><p><strong>知识要点：</strong></p><ul><li>采用递归思想遍历二叉树，自上而下同时遍历左右两边子树，镜像二叉树的判断条件有三点：</li></ul><ol><li>左子树的根节点值与右子树根节点值相同，<code>l.val = r.val</code>。</li><li>左子树的左侧叶节点等于右子树的右侧叶节点，左子树的右侧叶节点等于右子树的左侧叶节点，<code>self.isMirror(l.left,r.right) and self.isMirror(l.right,r.left)</code>。</li><li>左子树和右子树同时遍历完毕,<code>l== None and r == None:</code>，即证明该树对称。如果其中一侧遍历完毕而另一侧没有，则证明该树不对称。</li></ol><h2 id="6-二叉树的最大深度"><a href="#6-二叉树的最大深度" class="headerlink" title="6.二叉树的最大深度"></a>6.二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明</strong>: 叶子节点是指没有子节点的节点。</p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回它的最大深度 3 。</p><p>给定二叉树 <code>[1,2,7,3,4,null,null,null,5,6]</code></p><pre><code>        1       / \      2   7     / \    3   4       / \      5   6</code></pre><p>返回它的最大深度 4 。</p><pre><code class="python">class Solution(object):    def maxDepth(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: int        &quot;&quot;&quot;        if root is None:            return 0        sub_left = root.left        sub_right = root.right        return 1 + max(self.maxDepth(sub_left) , self.maxDepth(sub_right))</code></pre><p><strong>知识要点：</strong></p><ul><li>采用递归思想遍历二叉树，自上而下先遍历左边，后右边，每往下递进一层便+1，比较左子树和右字数的最大深度，并返回。</li><li><em><code>H = 1 + max(H(2),H(7))</code> = 4*</em></li><li><em><code>H(2) = 1 + max(H(3),H(4))</code> = 3*</em><br><code>H(3) = 1 + max(0,0)</code> = 1</li><li><em><code>H(4) = 1 + max(H(5),H(6))</code> = 2*</em><br><code>H(5) = 1 + max(0,0)</code> = 1<br><code>H(6) = 1 + max(0,0)</code> = 1<br><code>H(7) = 1 + max(0,0)</code> = 1</li></ul><h2 id="7-买卖股票的最佳时机"><a href="#7-买卖股票的最佳时机" class="headerlink" title="7.买卖股票的最佳时机"></a>7.买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong><br><code>输入：[7,1,5,3,6,4]</code><br><code>输出: 5</code><br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<em>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</em></p><p><strong>示例 2:</strong><br><code>输入：[7,6,4,3,1]</code><br><code>输出: 0</code><br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><pre><code class="python">class Solution(object):    def maxProfit(self, prices):        &quot;&quot;&quot;        :type prices: List[int]        :rtype: int        &quot;&quot;&quot;        min_price = float(&#39;inf&#39;)        max_profit = 0        for i in range(len(prices)):            if prices[i] &lt; min_price:                min_price = prices[i]            profit = prices[i] - min_price            if profit &gt; max_profit:                max_profit = profit        return max_profit</code></pre><p><strong>知识要点：</strong><br><img src="/img/stock.png" srcset="/img/loading.gif" alt=""><br>使我们感兴趣的点是上图中的峰和谷。我们需要找到最小的谷之后的最大的峰。<br>我们可以维持两个变量——minprice 和 maxprofit，它们分别对应<strong>迄今为止</strong>所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。</p>]]></content>
    
    
    <categories>
      
      <category>Top100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>